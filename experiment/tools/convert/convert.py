import math
import os
import pickle
import sys

import numpy as np

# sys.path.append(os.path.abspath(os.path.join('./', 'gpsy')))
from gpsy.primitive_set import PrimitiveSet
from gpsy.node import Node


# Useful path directory.
root_dir = (f'{os.path.dirname(os.path.abspath(__file__))}/../../results/'
            f'programs')


# Define some GP functions.

def add(x1, x2):
    """Return result of addition."""
    return x1 + x2

def aq(x1, x2):
    """Return result of analytical quotient.
    
    The analytical quotient is as defined by Ni et al. in their paper 
    'The use of an analytic quotient operator in genetic programming':  
    `aq(x1, x2) = (x1)/(sqrt(1+x2^(2)))`.
    """
    return (x1) / (math.sqrt(1 + x2 ** (2)))

def exp(x): 
    """Return result of exponentiation, base `e`."""
    return math.exp(x)

def log(x):
    """Return result of protected logarithm, base `e`."""
    if x != 0:
        return math.log(abs(x))
    else:
        return 0

def mul(x1, x2):
    """Return result of multiplication."""
    return x1 * x2

def sin(x):
    """Return result of sine."""
    return math.sin(x)

def sqrt(x):
    """Return result of protected square root."""
    try:
        return math.sqrt(x)
    except ValueError:
        # Input is negative.
        return 0

def sub(x1, x2):
    """Return result of subtraction."""
    return x1 - x2

def tanh(x):
    """Return result of hyperbolic tangent."""
    return math.tanh(x)


# Primitive set names.
names = ('nicolau_a', 'nicolau_b', 'nicolau_c')

# Function sets.
functions = ((add, sub, mul, aq),
             (sin, tanh, add, sub, mul, aq),
             (sin, tanh, exp, log, sqrt, add, sub, mul, aq))

# Constant sets.
constants = []
for name in names:
    with open(f'{root_dir}/{name}/constants.txt', 'r') as f:
        constants.append(f.read().splitlines())

# Tuples for maximum program size and 'size bin' size.
sizes = ((1023, 32), (255, 8), (127, 4))

# Numbers of fitness cases.
num_fitness_cases = (10, 100, 1000, 10000, 100000)

# Number of programs per size bin.
num_programs_per_bin = 128

# Primitive sets.
primitive_sets = {name: PrimitiveSet() for name in names}
for name, functions, constants in zip(names, functions, constants):
    for f in functions:
        primitive_sets[name].add_function(f)
    for _ in range(len(functions)-1):
        primitive_sets[name].add_variable_terminal()
    for c in constants:
        primitive_sets[name].add_constant_terminal(c)

# Read in fitness cases and target vectors generated by DEAP.
with open(f'{root_dir}/inputs.pkl', 'rb') as f:
    inputs = pickle.load(f)
with open(f'{root_dir}/target.pkl', 'rb') as f:
    target = pickle.load(f)

# Infer `NumPy` arrays from fitness case tuples.
inputs = np.array(inputs)
target = np.array(target)

# Retrieve and convert programs to various notations.
for ((m, (name, ps)), (max_size, bin_size)) in zip(
    enumerate(primitive_sets.items()), sizes):

    # Number of variables.
    num_variables = len(ps.variable_terminals)

    # Retrieve programs generated by DEAP.
    with open(f'{root_dir}/{name}/programs_deap.txt', 'r') as f:
        programs = f.read().splitlines()

    # Convert to `Node` objects.
    programs = [Node.from_str(p) for p in programs]

    ####################################################################

    # Convert to Operon strings.
    programs_ = [p.inorder_str for p in programs]

    # Write Operon programs.
    with open(f'{root_dir}/{name}/programs_operon.txt', 'w+') as f:
        for p in programs_:
            f.write(f'{p}\n')

    # Write Operon fitness cases.
    for nfc in num_fitness_cases:
        with open(f'{root_dir}/{name}/fitness_cases/{nfc}.csv', 'w+') as f:
            # Write header.
            f.write(','.join([f'v{n}' for n in range(num_variables)]) + ',y\n')

            # Write data.
            for i in range(nfc):
                f.write(','.join([str(v) for v in inputs[i, :num_variables]]))
                f.write(f',{target[i]}\n')

    ####################################################################

    # Convert to TensorGP strings.
    programs_ = [p.tensorgp_str(ps) for p in programs]

    # Write TensorGP programs.
    with open(f'{root_dir}/{name}/programs_tensorgp.txt', 'w+') as f:
        for p in programs_:
            f.write(f'{p}\n')

    ####################################################################

    # For each size bin, convert `num_programs_per_bin` programs to 
    # the relevant assembly language.

    # Maximum number of program memory locations.
    # An extra memory location is given for 'null' separators.
    depth = (max_size+1)*num_programs_per_bin

    # Address and data widths for assembly language, base 16.
    addr_width = int(math.ceil(math.log(depth, 16)))
    data_width = int(math.ceil(math.log(len(ps.assembly_language), 16)))

    for i in range(1, int(math.ceil(max_size/bin_size))+1):
        # Programs for bin `i`.
        bin = programs[(i-1)*num_programs_per_bin:(i)*num_programs_per_bin]
        with open(
            f'{root_dir}/{name}/mif/programs_bin{i}.mif', 'w+') as f:
            # Write MIF header.
            f.write(f'DEPTH = {depth};\n')
            f.write(f'WIDTH = {data_width};\n')
            f.write(f'ADDRESS RADIX = HEX;\n')
            f.write(f'DATA RADIX = HEX;\n')
            f.write(f'CONTENT\n')
            f.write(f'BEGIN\n\n')

            # Write MIF data.
            for j, program in enumerate(bin):
                # For each program...
                for k, node in enumerate(program.preorder + ('null',)):
                    # For each node...
                    addr = j * (max_size+1) + k
                    f.write(f'{addr:0{addr_width}X} : '
                            f'{ps.opcode(node, "X")};\n')
                if k < max_size:
                    # The current program did not utilize all 
                    # of its allocated memory; initialize the 
                    # remainder of the relevant program memory 
                    # locations to zero.
                    addrl = j * (max_size+1) + (k+1)
                    addrh = (j+1) * max_size + 1
                    f.write(f'[{addrl:0{addr_width}X}..'
                            f'{addrh:0{addr_width}X}] : '
                            f'{0:0{data_width}X};\n')
            f.write(f'\nEND;')

    ####################################################################

    # # For each size bin, convert `num_programs_per_bin` programs to 
    # # the relevant assembly language (tuple).

    # # Maximum number of program memory locations.
    # # An extra memory location is given for 'null' separators.
    # depth = (max_size+1)*num_programs_per_bin

    # # Address and data widths for assembly language, base 8.
    # addr_width = int(math.ceil(math.log(depth, 16)))
    # data_width = int(math.ceil(math.log(len(ps.assembly_language), 16)))
    # opcode_width = int(math.ceil(math.log(len(ps.assembly_language), 2)))

    # num_bins = int(math.ceil(max_size/bin_size))

    # with open(f'{root_dir}/{name}/programs_tuples_pkg.vhd', 'w+') as f:

    #     # Write package header.
    #     f.write(f'library gp;\n')
    #     f.write(f'context gp.std_context;\n\n')
    #     f.write(f'package programs_tuples_{name}_pkg is \n\n')

    #     f.write(f'  constant opcode_type : type_t := '
    #             f'uint_type({opcode_width});\n')
    #     f.write(f'  constant opcode_width : positive := '
    #             f'get_width(opcode_type);\n\n')
    #     f.write(f'  constant programs : tuple_array(0 to {num_bins-1})'
    #         f'(0 to {depth-1})({opcode_width-1} downto 0) := (\n')

    #     for i in range(1, num_bins+1):
    #         # Programs for bin `i`.
    #         f.write(f'    -- Bin `{i}`...\n')
    #         f.write(f'    {i-1} => (\n')
    #         bin = programs[(i-1)*num_programs_per_bin:(i)*num_programs_per_bin]

    #         # Write tuple data.
    #         for j, program in enumerate(bin):
    #             # For each program...
    #             f.write(f'      -- Program {j}...\n')
    #             for k, node in enumerate(program.preorder):
    #                 # For each node...
    #                 addr = j * (max_size+1) + k
    #                 f.write(f'      {addr} => '
    #                         f'to_slv(opcode_type, '
    #                         f'16#{ps.opcode(node, "X")}#),\n')

    #             # Add null.
    #             addrl = j * (max_size+1) + (k+1)
    #             addrh = (j+1) * (max_size + 1) - 1
    #             f.write(f'      {addrl} to {addrh} => '
    #                     f"(others => '0')")
    #             if j < num_programs_per_bin - 1:
    #                 f.write(',\n\n')
    #             else:
    #                 f.write('\n')
                
    #         f.write('  )')

    #         if i < num_bins:
    #             f.write(',\n\n')
    #         else:
    #             f.write('\n')

    #     f.write(f');\n\n')

    #     f.write(f'end package;')

    ####################################################################

    # Create C++ header file containing fitness outputs for each number 
    # of fitness cases, for each function set.

    # Fitness output results from DEAP.
    with open(f'{root_dir}/../results_deap.pkl', 'rb') as f:
        fitnesses, _ = pickle.load(f)

    num_bins = int(math.ceil(max_size/bin_size))

    for i, nfc in enumerate(num_fitness_cases):
    # for i, nfc in enumerate(num_fitness_cases):

        with open(f'{root_dir}/{name}/fitness_outputs/{nfc}.hpp', 'w+') as f:

            f.write(f'#include <limits>\n\n')

            f.write(f'float fitnesses_{name}_{nfc}'
                    f'[{num_bins}][{num_programs_per_bin}] = '
                    f'{{\n')

            for j in range(1, num_bins+1):
                # Fitnesses for bin `i`.
                f.write(f'  // Bin `{j}`...\n')
                f.write(f'  {{\n')

                for k in range(num_programs_per_bin):
                    # Write fitness output.
                    fitness = fitnesses[m][i][j-1][k]
                    fitness = fitness if fitness != float('inf') else (
                        'std::numeric_limits<float>::infinity()')
                    f.write(f'    {fitness},\n')

                f.write(f'  }}')

                if j < num_bins:
                    f.write(',\n\n')
                else:
                    f.write('\n')

            f.write(f'}};\n\n')

    ####################################################################

    # Create C++ header file containing programs for each function set.

    with open(f'{root_dir}/{name}/programs.hpp', 'w+') as f:

        f.write(f'uint8_t programs[{num_bins}][{num_programs_per_bin}]'
                f'[{max_size+1}] = {{\n')

        for i in range(1, num_bins+1):
            # Programs for bin `i`.
            f.write(f'  // Bin `{i}`...\n')
            f.write(f'  {{\n')

            bin = programs[(i-1)*num_programs_per_bin:(i)*num_programs_per_bin]

            # Write opcode data.
            for j, program in enumerate(bin):
                # For each program...
                f.write(f'    // Program {j}...\n')
                f.write(f'    {{\n')

                for node in program.preorder:
                    # For each node...
                    f.write(f'      0x{ps.opcode(node, "X")},\n')

                # Add null.
                f.write(f'      0x00\n')
                f.write(f'    }}')

                if j < num_programs_per_bin - 1:
                    f.write(',\n\n')
                else:
                    f.write('\n')
                
            f.write(f'  }}')

            if i < num_bins:
                f.write(',\n\n')
            else:
                f.write('\n')

        f.write(f'}};\n\n')

    ####################################################################